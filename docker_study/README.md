# docker_study
## VM
  * 실제 컴퓨터와 같은 프로그램을 실행하는 실제 컴퓨터의 에뮬레이션
  * VM은 "하이바이저"를 사용하여 물리적 컴퓨터의 상단에 실행
  * 하이퍼바이저는 호스트 기계 또는 "베어 메탈"에서 실행
  
  * 하이퍼바이저
  
      * VM이 위에서 실행되는 소프트웨어, 펌웨어 또는 하드웨어의 한 조각
      * 하이퍼 바이저는 "호스트 머신"에서 실행
      
          * 호스트 머신은 RAM 및 CPU를 포함한 리소스를 VM에 제공
          * 하나의 VM이 리소스가 많은 응용 프로그램을 실행하는 경우 동일한 호스트 컴퓨터에서 실행되는 다른 VM보다 더 많은 리소스를 할당할 수 있다. 
          
       
  * 게스트 컴퓨터
  
      * 호스트 컴퓨터에서 실행되는 VM
      * 응용 프로그램과 해당 응용 프로그램을 실행하는 데 필요한 모든 것이 포함되어 있다.
      * 가상화된 네트워크 어댑터, 스토리지 및 CPU를 포함하여 가상화된 하드웨어 스택 전체를 탑재한 게스트 운영 체제 보유
      * 내부에서 게스트 기계는 자체 전용 리소스가 있는 자체 장치로 행동
      * 게스트 기계는 호스팅 된 '하이퍼바이저' 또는 '베어 메탈 하이퍼바이저'에서 실행할 수 있다 
  
          * VM은 하드웨어에 직접 엑세스할 수 없으므로 호스트 운영체제를 거쳐야 한다.
          
   * 호스팅 하이퍼바이저 / 베어 메탈 하이퍼바이저
      
      * 호스팅 하이퍼 바이저
          
          * 호스트 운영 체제는 하이퍼바이저 자체 대신 하드웨어 드라이버를 담당하므로 더 많은 '하드웨어 호환성'이 있는 것으로 간주된다.
          * 반면, 하드웨어와 하이퍼바이저 사이에 있는 추가 레이어는 더 많은 리소스 오버헤드를 생성하여 VM 성능을 저하시킨다.
          
       * 베어 메탈 하이퍼바이저
       
          * 호스트 기계의 하드웨어를 설치하고 실행하여 성능 문제 해결
          * 기본 하드웨어와 직접 인터페이스하기 때문에 실행 시 호스트 운영 체제가 필요 없음
          * 운영 체제가 하이퍼바이저이기 때문에 호스트 컴퓨터 서버에 가장 먼저 설치됨
          * 자체 장치 드라이버를 가지고 있으며 모든 I/O 처리 또는 OS별 작업을 위해 각 구성요소와 직접 상호 작용
          * 이로 인해 성능, 확장성 및 안전성은 향상되지만, 하이퍼바이저에 너무 많은 장치 드라이버를 내장하기 때문에 하드웨어 호환성이 제한적이다.
          
          
   * 하이퍼바이저 레이어 역할
   
      * VM의 게스트 운영 체제를 관리하고 실행할 수 있는 플랫폼을 제공하는 데 필수적인 역할
      * 호스트 컴퓨터가 게스트로 실행되는 가상 컴퓨터 간에 리소스를 공유할 수 있다.
              
          <img src="https://miro.medium.com/max/875/1*RKPXdVaqHRzmQ5RPBH_d-g.png" width="400px" height="300px"></img><br/>
          
          * 이처럼 VM은 가상 하드웨어, 커널 및 각 새 VM에 대한 사용자 공간을 패키지화 한다.
          
          
## 컨테이너

   * 하드웨어 가상화를 제공하는 VM과 달리 컨테이너는 "사용자 공간"을 추상화하여 운영체제 수준 가상화 제공
   * 애플리케이션과 바이너리, 라이브러리 등을 패키지로 묶어 배포
   
   *  컨테이너 / VM 차이점
   
      * 컨테이너는 share 호스트 시스템의 커널을 다른 컨테이너와 공유함
      
          <img src="https://miro.medium.com/max/875/1*V5N9gJdnToIrgAgVJTtl_w.png" width="400px" height="300px"></img><br/>
          
          * 컨테이너는 VM과 달리 사용자 공간을 패키지화
          * 각 컨테이너는 자체 격리된 사용자 공간을 확보하여 단일 호스트 컴퓨터에서 여러 컨테이너를 실행할 수 있도록 한다.
          * 모든 운영 체제 수준 아키텍처를 컨테이너 간에 공유
          
          * VM : 하이퍼바이저를 사용하여 하드웨어를 에뮬레이션하고 이를 통해 여러 운영 체제를 동시에 실행
          
          * 컨테이너 : 운영 체제에서 기본으로 실행되고, 모든 컨테이너에서 운영 체제를 공유하므로 애플리케이션과 서비스를 가볍게 유지할 수 있고 빠른 속도로 동시 실행 가능 
          
          <img src="https://www.redhat.com/cms/managed-files/virtualization-vs-containers.png" width="350px" height="150px"></img><br/>
          
   * NameSapce
      
      * 컨테이너가 보고 액세스할 수 있는 것을 제한하여 기본 linux 시스템에 대한 고유한 보기를 컨테이너에 제공
      * 컨테이너를 실행하면 Docker는 특정 컨테이너가 사용할 네임스페이스 만듦
      
   * Cgroups
   
      * 프로세스 집합의 리소스 사용(CPU, 메모리, 디스크 I/O, 네트워크 등)을 격리, 우선 순위 지정 및 계정으로 지정하는 linux 커널 기능
      * cgroup은 Docker 컨테이너가 필요한 리소스만 사용하도록 보장하고 필요한 경우 컨테이너가 사용할 수 있는 리소스에 대한 제한을 설정
      * 단일 컨테이너가 이러한 리소스 중 하나를 소모하지 않고 전체 시스템을 다운하지 않도록 함
          
          
   * 컨테이너 런타임
  
      * OCI : 애플리케이션의 이식성 관점에서 컨테이너 포맷과 런타임에 대한 개방형 업계 표준
      * 컨테이너 실행 단계 : 이미지 다운로드 -> 이미지 압축 해제 -> 컨테이너 실행
      
          * OCI가 만들어질 당시 비공식적 표준 역할을 하던 도커는 컨테이너 실행 부분만 표준화함
          * 이로 인해 컨테이너 런타임은 실제 컨테이너를 실행하는 저수준 컨테이너 런타임인 OCI 런타임과 이미지의 전송 및 관리, 이미지 압축 풀기 등을 실행하는 고수준 컨테이너 런타임으로 나뉘게 되었다
   
      * 저수준 컨테이너 런타임
      
          * namespace와 cgroup을 설정한 다음 해당 namespace 및 cgroup 내에서 명령 실행                   
          * OCI를 준수하는 저수준 컨테이너 런타임에는 runC가 있다.
          * 저수준 컨테이너 런타임은 컨테이너를 실제 실행하는 역할을 하지만 이미지로부터 컨테이너를 실행하려면 이미지와 관련된 API같은 기능이 필요 -> 고수준 컨테이너 런타임에서 제공
          
       * 고수준 컨테이너 런타임
       
          * 원격 애플리케이션이 컨테이너를 논리적으로 실행하고 모니터링 하는데 사용할 수 있는 데몬 및 API 제공
          * 컨테이너를 실행하기 위해 저수준 런타임 위에 배치
          
          * 이처럼 컨테이너를 실행하려면 저수준 및 고수준 컨테이너 런타임이 필요하기 때문에 OCI 런타임과 함께 도커가 그 역할을 했다.
          * 도커는 docker-containerd라는 고수준 컨테이너 런타임 제공
          
          
   * CRI (Container Runtime Interface)
   
       * 쿠버네티스에서 만든 컨테이너 런타임 인터페이스 
       * 명확하게 정의된 추상화 계층을 제공함으로써 개발자가 컨테이너 런타임 구축에 집중할 수 있게 함
       
          * 기본적으로 도커 기반의 쿠버네티스는 kubelet이 명령을 받으면 Docker runtime을 통해서 컨테이너를 생성하거나 삭제하는 것과 같은 생명 주기를 관리하는 구조를 가지고 있었다
          
          * 하지만, 다양한 컨테이너 런타임을 지원하기 위해서 그 때마다 kubelet의 코드를 수정해야되는 문제가 발생함
          
          * 그래서, kubelet의 코드를 수정하지 않고, 다양한 컨테이너 런타임을 지원하기 위해서, kubelet과 컨테이너 런타임 사이의 인터페이스를 통일화하는 CRI 등장
          
     
   * CRI-O
      
       * CRI와 OCI에서 유래된 프로젝트로 컨테이너 런타임 및 이미지가 OCI와 호환되는 것에 중점을 두고 있다
       * CRI 표준 컴포넌트를 최소한의 런타임으로 구현하며 쿠버네티스에서 모든 OCI 호환 런타임 및 컨테이너 이미지 지원
       
       * CRI-O는 컨테이너 실행목적이기 때문에 도커가 제공하는 컨테이너 생성 및 이미지 빌드와 같은 기능은 제공하지 않는다
       
       
   * 도커의 문제점
   
       * 도커가 컨테이너의 생성 및 이미지 빌드를 모두 처리하는데 새로운 툴이 필요한 이유
          
          * 도커는 클라이언트/서버 애플리케이션으로 클라이언트인 Docker CLI와 서버인 Docker daemon으로 구성된다
          * 그 중 서버는 컨테이너 이미지 빌드, 관리, 공유, 실행 및 컨테이너 인스턴스 관리와 같이 너무 많은 기능을 담당하는 데몬으로 모든 컨테이너를 자식 프로세스로 소유
          
          * 이로 인해 무거울 뿐 아니라 장애가 발생하면 모든 자식 프로세스에 영향을 끼쳐 단일 실패점이 될 위험이 있다.
          * 클라이언트-서버 모델을 사용할 경우 audit 보안 기능을 사용할 수 없게 된다
          
  
 ## Docker
 
   * 컨테이너를 기반으로 하는 오픈 소스 프로젝트
   
   * docker 장점
   
      1. 사용 편의성 : 누구나 노트북에 응용 프로그램을 패키징할 수 있으며 이는 어디서나 실행할 수 있다.
          
      2. 속도 : 컨테이너는 커널에서 실행되는 샌드박스 환경일 뿐이므로 리소스가 줄어드러 매우 가볍고 빠르다.
          
      3. Docker Hub : 사용자는 Docker Hub (Docker 이미지용 앱 스토어) 에코시스템의 혜택을 누릴 수 있다
      
      4. 모듈성 및 확장성 : 응용 프로그램의 기능을 개별 컨테이너로 쉽게 탈수할 수 있다. 
      
   * docker 개념
   
      * 도커 엔진
          
          * Docker가 실행되는 레이어
          * 컨테이너, 이미지, 빌드 등을 관리하는 경량 런타임 및 툴링
          
          1. 호스트 컴퓨터에서 실행되는 Docker Daemon
          2. 명령을 실행하기 위해 Docker Daemon과 통신하는 Docker 클라이언트
          3. 원격으로 도커 데몬과 상호 작용하는 REST API
          
       * 도커 클라이언트
          
          * Docker의 최종 사용자로서 통신하는 것
          * Docker 클라이언트와 통신한 후 지침을 Docker Daemon에 전달
          
        * 도커 데몬
        
          * 컨테이너를 빌드, 실행 및 배포하는 것과 같이 Docker 클라이언트로 전송된 명령을 실제로 실행
          * Docker Daemon은 호스트 컴퓨터에서 실행되지만 사용자로서 데몬과 직접 통신하지 않는다
          
        * 도커 파일
            
          * Docker 이미지를 빌드하는 지침을 작성하는 곳
              
        * 도커 이미지
        
          * Dockerfile에 기록된 지침 집합에서 빌드한 읽기 전용 템플릿
          * Docker 이미지는 Dockerfile을 사용하여 빌드
          * Dockerfile의 각 명령은 이미지에 새 레이어를 추가하거나 대체
          * Docker는 유니온 파일시스템을 사용하여 이를 수행
          
        * 유니온 파일 시스템
        
          * Docker는 유니온 파일 시스템을 사용하여 이미지를 구축한다.
          * 스택 파일 시스템으로 생각할 수 있고, 별도의 파일 시스템의 파일 및 디렉토리를 투명하게 오버레이하여 단일 파일 시스템을 형성할 수 있다.
              
              * 오버레이 된 파일 시스템 내에서 동일한 경로를 갖는 디렉터리의 내용은 단일 병합된 디렉터리로 보아 각 레이어의 별도 복사본을 만들 필요가 없다.
              * 특정 레이어를 수정해야 하는 경우 복사본을 만들고 로컬 복사본을 수정하여 원본을 변경하지 않는다
              
                  * 읽기 전용 파일을 실행할 경우, 해당 파일에 대해 쓰기가 가능한 임시 파일을 생성하여 읽기 파일을 그대로 복제하여 실행을 하게 된다.
                  
                  * 그 다음, 수정이 된 내용에 대해 모두 사용하였다면 쓰기 작업을 진행한 다음, 기존의 읽기 파일을 대체한다 이러한 방식
              
          * 계층화된 시스템의 이점
              
              * 중복 되지 않는다
                
                  * 레이어는 이미지를 사용하여 새 컨테이너를 만들고 실행할 때마다 전체 파일 집합을 복제하지 않도록 하여 Docker 컨테이터를 매우 빠르고 저렴하게 인스턴스화하는 데 도움이 된다.
                  
              * 레이어 분리
              
                  * 변경 속도가 훨씬 빠르다. 이미지를 변경할 때 Docker는 변경된 레이어에만 업데이트를 전파
                  
        * 볼륨
        
           * 컨테이너를 만들 때 초기화된 컨테이너의 '데이터' 부분
           * 볼륨을 사용하면 컨테이너의 데이터를 유지 및 공유할 수 있다.
           * 데이터 볼륨은 기본 유니온 파일 시스템과 분리되어 호스트 파일 시스템의 일반 디렉터리 및 파일로 존재
           * 컨테이너를 파괴, 업데이트 또는 다시 빌드하더라도 데이터 볼륨은 그대로 유지
           * 볼륨을 업데이트하려면 볼륨을 직접 변경
           * 데이터 볼륨을 공유하고 여러 컨테이너 간에 재사용할 수 있으며 이는 매우 깔끔하게 처리된다
           
        * 도커 컨테이너
        
           * 운영 체제, 응용 프로그램 코드, 런타임, 시스템 도구 등 응용 프로그램의 소프트웨어를 보이지 않는 상자에 넣는 것
           * Docker 이미지를 기반으로 한다
           * Docker는 이미지의 읽기 전용 파일 시스템에 읽기 쓰기 파일 시스템을 추가하여 컨테이너 만듦 
           * 컨테이너를 만든 Docker는 네트워크 인터페이스를 만든다
           
          
        
      
          
         
          
   
          
 
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      
      
   
